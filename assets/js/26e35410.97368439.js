"use strict";(self.webpackChunkpersonal_website=self.webpackChunkpersonal_website||[]).push([[637],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=u(n),c=a,h=m["".concat(s,".").concat(c)]||m[c]||d[c]||i;return n?r.createElement(h,l(l({ref:t},p),{},{components:n})):r.createElement(h,l({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:a,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5517:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const i={title:"Problems 1 - 50",sidebar_label:"1 - 50",pagination_label:"Problems 1 - 50",pagination_prev:"algorithms/index",pagination_next:null,toc_min_heading_level:3,toc_max_heading_level:3},l=void 0,o={unversionedId:"algorithms/leetcode/0001_0050",id:"algorithms/leetcode/0001_0050",title:"Problems 1 - 50",description:"1. Two Sum link",source:"@site/notes/algorithms/leetcode/0001_0050.mdx",sourceDirName:"algorithms/leetcode",slug:"/algorithms/leetcode/0001_0050",permalink:"/personal_website/notes/algorithms/leetcode/0001_0050",draft:!1,editUrl:"https://github.com/KushajveerSingh/personal_website/tree/main/notes/algorithms/leetcode/0001_0050.mdx",tags:[],version:"current",frontMatter:{title:"Problems 1 - 50",sidebar_label:"1 - 50",pagination_label:"Problems 1 - 50",pagination_prev:"algorithms/index",pagination_next:null,toc_min_heading_level:3,toc_max_heading_level:3},sidebar:"algorithms",previous:{title:"Algorithms",permalink:"/personal_website/notes/algorithms/"}},s={},u=[{value:"1. Two Sum link",id:"1-two-sum-link",level:3},{value:"2. Add Two Numbers link",id:"2-add-two-numbers-link",level:3},{value:"3. Longest Substring Without Repeating Characters link",id:"3-longest-substring-without-repeating-characters-link",level:3}],p={toc:u},m="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"1-two-sum-link"},"1. Two Sum ",(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/two-sum/description/"},"link")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Problem")),(0,a.kt)("p",null,"Given an array of unsorted integers, return indices of two numbers that add up to target value."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Idea")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Time = ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)"),", Space = ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)"),"."),(0,a.kt)("li",{parentName:"ul"},"Iterate through the array and store the current value and it's index in a hash map."),(0,a.kt)("li",{parentName:"ul"},'When iterating if you find "target - current_value" in the hash map, return the indices.')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Key = "first_num"\n        # Value = index of "first_num" in "nums"\n        d = {}\n\n        for i in range(len(nums)):\n            first_num = nums[i]\n            second_num = target - first_num\n\n            if second_num in d:\n                first_num_index = i\n                second_num_index = d[second_num]\n                return [first_num_index, second_num_index]\n\n            d[first_num] = i\n')),(0,a.kt)("h3",{id:"2-add-two-numbers-link"},"2. Add Two Numbers ",(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/add-two-numbers/"},"link")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Problem")),(0,a.kt)("p",null,"Given two linked lists represeting two non-negative integers (in reverse order), create a new linked list with the sum of those numbers."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"l1 = 2 -> 4 -> 3 (i.e. the number 342)"),(0,a.kt)("li",{parentName:"ul"},"l2 = 5 -> 6 -> 4 (i.e. the number 465)"),(0,a.kt)("li",{parentName:"ul"},"output = 7 -> 0 -> 8 (i.e. the number 807)")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Idea")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Time = ",(0,a.kt)("inlineCode",{parentName:"li"},"O(max(l1.length, l2.length))"),", Space = ",(0,a.kt)("inlineCode",{parentName:"li"},"O(1)")," (only the space for intermediate steps is considered here)."),(0,a.kt)("li",{parentName:"ul"},"Simultaneously iterate through both the lists and add their values."),(0,a.kt)("li",{parentName:"ul"},"Create a new node (in the output list) with the sum of the values (taking carry into account also).")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: [ListNode], l2: [ListNode]) -> [ListNode]:\n        # Helper function to avoid code duplication. Can be placed outside\n        # the function also.\n        def add_vals(l1, l2, carry):\n            # val = carry + l1.val + l2.val\n            val = carry\n            if l1 is not None:\n                val += l1.val\n                l1 = l1.next\n            if l2 is not None:\n                val += l2.val\n                l2 = l2.next\n\n            # Handle carry\n            if val >= 10:\n                val = val - 10\n                carry = 1\n            else:\n                carry = 0\n\n            # Return the modified lists, carry, and a new node with the \'val\'\n            return l1, l2, carry, ListNode(val)\n\n\n        # Create "root" node and initialize "head" pointer, as we want to return\n        # "root" as the final answer\n        l1, l2, carry, root = add_vals(l1, l2, 0)\n        head = root\n\n        # Check till l1 is empty, l2 is empty, and carry is 0\n        while (l1 is not None) or (l2 is not None) or (carry != 0):\n            l1, l2, carry, node = add_vals(l1, l2, carry)\n\n            head.next = node\n            head = head.next\n\n        return root\n')),(0,a.kt)("h3",{id:"3-longest-substring-without-repeating-characters-link"},"3. Longest Substring Without Repeating Characters ",(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/longest-substring-without-repeating-characters/"},"link")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Problem")),(0,a.kt)("p",null,"Find the length of the longest substring (contiguous non-empty sequence) without repeating characters in a string."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'s = "abcabcbb", out = 3 (i.e. "abc")'),(0,a.kt)("li",{parentName:"ul"},'s = "tmmzuxt", out = 5 (i.e. "mzuxt")')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Idea")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Time = ",(0,a.kt)("inlineCode",{parentName:"li"},"O(N)"),", Space = ",(0,a.kt)("inlineCode",{parentName:"li"},"O("),")` (as the characters you can use in the string is constant)."),(0,a.kt)("li",{parentName:"ul"},"Maintain the 'start' of the substring (i.e. the final output), and as you iterate through the string, update the 'start' to the index of the repeating character + 1."),(0,a.kt)("li",{parentName:"ul"},'For the string "tmmzuxt", iterate from left to right'),(0,a.kt)("li",{parentName:"ul"},'For "t", store its index "0" in hashmap and start = 0'),(0,a.kt)("li",{parentName:"ul"},'For "m", store "1" in hashmap, start still at 0, as no repeating character is found.'),(0,a.kt)("li",{parentName:"ul"},'For "m", we find "m" is already in the hashmap. So we update its value to "2", and update start to 2, as "tm" can never be part of the output now.')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        substring_start = 0\n        max_substring_length = 0\n\n        # Key = "character"\n        # Value = index of last seen "character" as we iterate through the string\n        d = {}\n\n        for i in range(len(s)):\n            c = s[i]\n\n            # Reason for adding "substring_start <= d[c]"\n            # Consider the string "tmmzuxt".\n            # When we reach the second "m", we update the start to 2, as "tm" can never\n            # be part of the output now.\n            # When we reach the last "t" i.e. "tmmzuxt", we already have the start at 2,\n            # i.e. the string we are considering is "mzuxt", so there is no point in\n            # checking "if c in d", becaues the first "t" is not part of the substring.\n            # An alternative approach is to delete the characters from the hashmap, as we\n            # update \'start\', but all those deletions add up and we end up doing an extra\n            # pass through the whole string. So this trick allows us to solve the problem\n            # in a single pass, rather than two passes.\n            if c in d and substring_start <= d[c]:\n                substring_start = d[c] + 1\n            else:\n                max_substring_length = max(max_substring_length, i - substring_start + 1)\n            d[c] = i\n\n        return max_substring_length\n')))}d.isMDXComponent=!0}}]);