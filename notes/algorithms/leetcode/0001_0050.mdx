---
title: Problems 1 - 50
sidebar_label: 1 - 50
pagination_label: Problems 1 - 50
pagination_prev: algorithms/index
pagination_next: null
toc_min_heading_level: 3
toc_max_heading_level: 3
---

### 1. Two Sum [link](https://leetcode.com/problems/two-sum/description/)

**Problem**

Given an array of unsorted integers, return indices of two numbers that add up to target value.

**Idea**

- Time = `O(N)`, Space = `O(N)`
- Iterate through the array and store the current value and it's index in a hash map.
- When iterating if you find "target - current_value" in the hash map, return the indices.

```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    # Key = "first_num"
    # Value = index of "first_num" in "nums"
    d = {}

    for i in range(len(nums)):
        first_num = nums[i]
        second_num = target - first_num

        if second_num in d:
            first_num_index = i
            second_num_index = d[second_num]
            return [first_num_index, second_num_index]

        d[first_num] = i
```

### 2. Add Two Numbers [link](https://leetcode.com/problems/add-two-numbers/)

**Problem**

Given two linked lists represeting two non-negative integers (in reverse order), create a new linked list with the sum of those numbers.

**Example**

- l1 = 2 -> 4 -> 3 (i.e. the number 342)
- l2 = 5 -> 6 -> 4 (i.e. the number 465)
- output = 7 -> 0 -> 8 (i.e. the number 807)

**Idea**

- Time = `O(max(l1.length, l2.length))`, Space = `O(1)` (only the space for intermediate steps is considered here)
- Simultaneously iterate through both the lists and add their values.
- Create a new node (in the output list) with the sum of the values (taking carry into account also).

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(self, l1: [ListNode], l2: [ListNode]) -> [ListNode]:
    # Helper function to avoid code duplication. Can be placed outside
    # the function also.
    def add_vals(l1, l2, carry):
        # val = carry + l1.val + l2.val
        val = carry
        if l1 is not None:
            val += l1.val
            l1 = l1.next
        if l2 is not None:
            val += l2.val
            l2 = l2.next

        # Handle carry
        if val >= 10:
            val = val - 10
            carry = 1
        else:
            carry = 0

        # Return the modified lists, carry, and a new node with the 'val'
        return l1, l2, carry, ListNode(val)


    # Create "root" node and initialize "head" pointer, as we want to return
    # "root" as the final answer
    l1, l2, carry, root = add_vals(l1, l2, 0)
    head = root

    # Check till l1 is empty, l2 is empty, and carry is 0
    while (l1 is not None) or (l2 is not None) or (carry != 0):
        l1, l2, carry, node = add_vals(l1, l2, carry)

        head.next = node
        head = head.next

    return root
```
